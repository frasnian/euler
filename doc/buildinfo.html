<!DOCTYPE html>
<html style="height:100%;">
<!--
// <copyright>
// This is a part of Euler Zero - see https://github.com/frasnian/euler-zero
// Copyright (c) 2015,2016 David Starr
//
// Distributed under the Boost Software License, Version 1.0. 
// (See accompanying file LICENSE_1_0.txt or copy at 
// http://www.boost.org/LICENSE_1_0.txt)
// </copyright>
-->
<head>
<meta charset="UTF-8"> 
<title>Euler Zero - Build &amp; Compiler Information</title>
<link rel="stylesheet" type="text/css" href="euler-zero.css">
<script type="text/javascript" src="common.js"></script>
<script type="text/javascript" src="stddocpage.js"></script>
<script type="text/javascript" src=".euler-zero-prefs.js"></script>

<script language="javascript"><!--

// yes, this is all super-ugly. I don't care - this is not a real commercial project
// so I'm going with quick & dirty here:
var leafClosedIndicator = '<font size="+1">&#8862;&#160;</font>';      // squared plus
var leafOpenIndicator   = '<font size="+1">&#8863;&#160;</font>';      // squared minus

function toggleNode(node){
    var oContent = document.getElementById(node.id + "_content");
    var oIndicator = document.getElementById(node.id + "_indicator");
    var sIndicator = "";
    if (oContent.style.display == "none"){
        sIndicator = leafOpenIndicator;
        oContent.style.display = "block";
    }
    else{
        sIndicator = leafClosedIndicator;
        oContent.style.display = "none";
    }
    oIndicator.innerHTML = sIndicator + '<span style="cursor:pointer;"><b>' +node.getAttribute("heading")+ '</b></span><br/>';
}

function updateExpandableNodes()
{
    var o = document.getElementsByClassName("expandable_node");
    for (var i = 0; i < o.length; ++i){
        var node = o[i];
        var node_content = node.innerHTML;
        var newContent 
            = '<div style="cursor:pointer;" id="' +node.id+ '_indicator" onclick="toggleNode2(this.parentElement)">' +leafClosedIndicator
            + '<span style="cursor:pointer;"><b>' +node.getAttribute("heading")+ '</b></span><br/>'
            + '</div>'
            + '<div id="' +node.id+'_content" style="display:none;">' +node_content +'</div>'
            ;        
        node.innerHTML = newContent;
    }
}



--></script>

</head>
<body onload="standardDocPageElements(true), updateExpandableNodes()" style="height:99%;">
<div id="content" style="height:100%;">
<h1>Euler Zero - Build &amp; Compiler Information</h1>
<p>
<b>Building Individual Solutions</b><br/>
There are no makefiles or project files, and I have no current plans to create them. The reason for this is that the make/project file issue immediately begs the question: for <i>which</i> build system? make? cmake? nmake? VC/Eclipse/Netbeans/etc project files? Each solution is a self-contained source file buildable with a simple command line and command lines work everywhere. It's not like this is a complex system with a team of developers and a boatload of dependencies.
</p>
<p>
If you want to actually build a particular solution, it&apos;s easy: the readme file for every solution can generate build command lines for several common compilers (gcc/g++, clang, MSVC, Intel).  All you should have to do is copy &amp; paste the command line generated by the readme file.  Compilers supported for each solution, as well as minimum versions required can be found in the readme file for that solution.  Build notes are also included within the readme file corresponding to each solution.
</p>
<p>
You can customize the default compiler switches and some other options that generate the build command lines with a local config file - see the <a href="docinfo.html">doc info page</a> for details. Note that if you change build defaults, you're on your own. As a C++ developer you should be okay with that.
</p>
<p>
Although the readme files for each solution will create build command lines for you, some of the gory details are below. You might want to read them if you're going to tweak the build options.
</p>

<div id="compver" class="expandable_node" onclick="toggleNode(this)" heading="Compiler Versions">
    The <i>minimum</i> compiler versions I currently check against are below.  Note that if a later compiler breaks something that worked in an earlier version, I might not know about it (for example, if I test against MSVC2003 and it works, I don't re-check against 2005,2008,etc.).  If I install or have access to any earlier versions at some point, I'll try to update this list but I probably won't go back and check solutions I've already posted. If you try an earlier version on a posted solution and it works, or a later version breaks something, please let me know.
    <table style="margin-left:16px;">
    <tr><td class="bld_command_table_entry">gcc / g++</td><td xalign="right">4.4.7</td></tr>
    <tr><td class="bld_command_table_entry">clang / clang++</td><td xalign="right">3.4.1</td></tr>
    <tr><td class="bld_command_table_entry">Intel C++</td><td xalign="right">13.0.1</td></tr>
    <tr><td class="bld_command_table_entry">MS Visual C++</td><td xalign="right">2003</td></tr>
    </table>
    <br/>The readme file for each solution will have the earliest compiler version (that I checked against) required for that solution.
    <p>
    I'll try to mention any known compiler/version issues in the readme file for a problem, but I'm certainly not planning on testing every single problem with every possible compiler variation.
    </p>
</div>

<div id="defoptions" class="expandable_node" onclick="toggleNode(this)" style="cursor:pointer;" heading="Default compiler options">
    The readme files generate build command lines based on solution/variant-specific options, but the following default compiler options are always used (NIX means compilers such as <code>gcc/g++/clang/clang++/icc</code> that take gcc-style options on Linux/BSD/UNIX platforms; MSVC means Visual C++ or other compilers that understand the same options).
    <p>
    <table style="margin-left:16px;">
    <tr>
        <td class="bld_command_table_hdr"><b>NIX</b></td>
        <td class="bld_command_table_hdr"><b>MSVC</b></td>
        <td class="bld_command_table_hdr"><b>Description</b></td>
    </tr>
    <tr>
        <td class="bld_command_table_entry"><code>-Werror</code></td>
        <td class="bld_command_table_entry"><code>/WX</code></td>
        <td>Treat warnings as errors</td>
    </tr>
    <tr>
        <td class="bld_command_table_entry"><code>-Wall -pedantic</code></td>
        <td class="bld_command_table_entry"><code>/W4</code></td>
        <td>Maximum warnings and bitchiness</td>
    </tr>
    <tr>
        <td class="bld_command_table_entry"><code>-O3</code></td>
        <td class="bld_command_table_entry"><code>/O2 /Ox /Ot</code></td>
        <td>Maximum optimization</td>
    </tr>
    <tr>
        <td class="bld_command_table_entry"><code></code></td>
        <td class="bld_command_table_entry"><code>/EHsc</code></td>
        <td>C++ exception handling; extern "C" defaults to "nothrow"</td>
    </tr>
    <tr>
        <td class="bld_command_table_entry"><code></code></td>
        <td class="bld_command_table_entry"><code>/Zc:forScope</code></td>
        <td>Enforce C++ <code>for</code> scoping rules. Really. This is considered an "option."</td>
    </tr>
    <!--
    <tr>
        <td class="bld_command_table_entry"></td>
        <td class="bld_command_table_entry">/EHsc /Zc:forScope</td>
        <td>Because MS C++ is sad. Look them up.</td>
    </tr>
    -->
    </table>
    <br/>Obviously, individual solutions will require additional options - check the readme for that problem.
    </p>
</div>

<div id="cmdline_zrt" class="expandable_node" onclick="toggleNode(this)" style="cursor:pointer;" heading="Build command lines - ZRT versions">
    The following are the typical command line options and arguments used (although individual problems may vary slightly, see the appropriate readme file):
    <p>
    For zero-runtime solutions, I usually just generate assembly output to verify the result. The assembly should be a single variable with the solution for that problem (no executable code should be generated):
    </p>
    <p>
    Using gcc, g++, clang, icc:<br/>
     <code class="indent">-S -O3 -Wall -Werror -pedantic --std=c++XX -oeuler<i>NNN</i> euler<i>NNN</i>-zrt.cpp</code>
    <br/>The resulting assembly output will be in <code>euler<i>NNN</i>.s</code>.
    </p>
    <p>
    If a separate CAX version is <I>not</I> included in the repository, the source file contains both implementations so you will need <code>-DCONSTEXPR=constexpr</code> (or equivalent) on the build command line.
    </p>
    <p>
    If you want to actually build an executable, just add <code>-DBUILD_ZRT_MAIN</code> to the command line. This will generate a barebones <code>main()</code>  that simply prints the solution result to <code>stdout</code>. You may have to also add something like <code>-lstdc++</code>  for some compilers to link correctly with the C++ runtime libraries. 
    Note that it's actually much easier to use Compiler Explorer if all you want is the generated assembly - just paste in the appropriate compiler options (obviously, omit the <code>-oeuler<I>NNN</I> euler<I>NNN</I>-zrt.cpp</code> bits), paste the solution source code into the input window, choose a compiler that supports the Standard required by the solution, and <I>presto!</I> This has the added benefit of eliding extraneous sections info (e.g. <code>comment,ident,note</code>, etc.) so the output is a lot cleaner. It also makes it easy to test against a compiler you might not have installed.
    </p>
</div>

<div id="cmdline_cax" class="expandable_node" onclick="toggleNode(this)" style="cursor:pointer;" heading="Build command lines - CAX versions">
    If a separate calculation-at-execution variant is included for a problem, building it will usually use the same command-line arguments as the zero-runtime version, except for an executable <code>-DBUILD_ZRT_MAIN</code> may not be needed - each will have its own <code>main()</code>  - and obviously you need to replace the source filename with <code>euler<i>NNN</i>-cax.cpp</code>.
    <p>
    Calculation-at-execution variants may also support older versions of the Standard than the ZRT version for the same problem - for specifics, see the readme file corresponding to that solution. 
    </p>
    <p>
    If a separate CAX version is not included, adding <code>-DCONSTEXPR=""</code> to your build command line should give you a calculation-at-execution version. Again, the corresponding readme file will have build details for a specific solution.
    </p>
</div>

</div>
</body>
</html>
