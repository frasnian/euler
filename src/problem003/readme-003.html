<!DOCTYPE html>
<html>
<!--
<copyright>
// This is a part of Euler Zero - see https://github.com/frasnian/euler-zero
// Copyright (c) 2015,2016 David Starr
//
// Distributed under the Boost Software License, Version 1.0. 
// (See accompanying file LICENSE_1_0.txt or copy at 
// http://www.boost.org/LICENSE_1_0.txt)
//
</copyright>
-->
<head>
<meta charset="UTF-8"> 
<link rel="stylesheet" type="text/css" href="../../doc/euler-zero.css">
<script type="text/javascript" src="../../doc/common.js"></script>
<script type="text/javascript" src="../../doc/euler-zero-problems.js"></script>
<script type="text/javascript" src="../../doc/.euler-zero-prefs.js" ></script>
<script language="javascript"><!--
var problemNumber = "003";

var clangNote = "This will compile with clang / clang++ v3.4.1+, but the <code>--std=c++14</code> option must be changed to <code>--std=c++1y</code>";

var gccNote = "This will compile with gcc / g++ v4.4.7, but you have to remove the <code>--std=c++11</code> and <code>-pedantic</code> command-line options.";

// Format: variant-tag, variant-name, required-standard, input-suffix, output-suffix, exe-definitions, supported-compilers[]
var supportedVariants = [
    new supportedVariant("zrt", "Zero-runtime", "c++14", "-zrt", "-zrt", "BUILD_ZRT_MAIN", [ 
        "gcc;5.1+;;",
        "gxx;5.1+;;",
        "clang;3.5+;;" + clangNote, 
        "clangxx;3.5+;;" + clangNote 
//        , "intel;??+;",  // Intel compilers as of icc17 choke on this solution
        ]),
    new supportedVariant("cax", "Calc-at-execution", "c++98", "-zrt", "-cax", "BUILD_ZRT_MAIN", [ 
        "gcc;4.4.7+;-DEULER_ZERO_CAX -Wno-long-long;" + gccNote,
        "gxx;4.4.7+;-DEULER_ZERO_CAX -Wno-long-long;" + gccNote,
        "clang;3.4.1+;-DEULER_ZERO_CAX -Wno-long-long", 
        "clangxx;3.4.1+;-DEULER_ZERO_CAX -Wno-long-long", 
        "intel;13.0.1+;-DEULER_ZERO_CAX -Wno-long-long; Intel C++ will compile this without the <code>-Wno-long-long</code> option      (at least as of icc17). Technically, it shouldn't.", 
        "msvc;2003+;/DEULER_ZERO_CAX"
        ])
];
--></script>
</head>
<body onload="standardPageElements()">
<div id="content">
<div id="ezero_intro"></div>

<div id="ezero_problem">
<div class="problem_statement">
    <br/>The prime factors of 13195 are 5, 7, 13 and 29.
    <p>What is the largest prime factor of the number 600851475143 ?</p>
</div>
</div> <!-- ezero_problem -->
<p></p>

<div id="ezero_solution">
All this problem really needs is a basic function to figure out the largest prime factor.  As with Problem 2, the problem essentially describes the solution.
<p>
I used a simple (and common) method of sucessive division to test candidate divisors - by
sccessively dividing by smaller candidate numbers, larger multiples of those numbers (which will
by definition be non-prime) will be eliminated as we increment our candidate number. It costs 
an extra division for each non-prime we've already tested a divisor of, but this is more than 
offset by skipping the cost of trying to test each candidate divisor for primality. It also has 
the advantage of simplicity. I certainly didn't think of this method first (no idea where I 
first saw it) and there are probably methods that are faster, but it doesn't matter as much here
because the point for this project is zero-runtime (all calculations are actually done before 
the program is ever run).
</p>
<p>For the zero-runtime version, the C++14 relaxations on constexpr functions are used. 
The code is exactly the same for both the calc-at-execution and zero-runtime 
implementations - the CAX version just hides constexpr.with a #define directive 
(hiding a keyword with the preprocessor is extremely bad practice, but this isn't a real program). 
The CAX version also needs the <code>-Wno-long-long</code> option for some compilers, as <code>'long long'</code>
is not officially part of ISO C++ 1998 (it's a compiler extension prior to C++11) and we treat 
all warnings as errors.
 </p>
</div> <!-- ezero_solution -->

</div> <!-- content -->
</body>
</html>
