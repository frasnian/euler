<!DOCTYPE html>
<html style="height:100%;">
<!--
<copyright>
// This is a part of Euler Zero - see https://github.com/frasnian/euler-zero
// Copyright (c) 2015,2016 David Starr
//
// Distributed under the Boost Software License, Version 1.0. 
// (See accompanying file LICENSE_1_0.txt or copy at 
// http://www.boost.org/LICENSE_1_0.txt)
//
</copyright>
-->
<head>
<meta charset="UTF-8"> 
<link rel="stylesheet" type="text/css" href="../../doc/euler-zero.css">
<script type="text/javascript" src="../../doc/common.js"></script>
<script type="text/javascript" src="../../doc/euler-zero-problems.js"></script>
<script type="text/javascript" src="../../doc/.euler-zero-prefs.js" ></script>
<script type="text/javascript" src="ezp-docvar-003.js"></script>
</head>
<body onload="standardReadmePageElements()">

<div id="ezero_problem">
    <br/>The prime factors of 13195 are 5, 7, 13 and 29.
    <p>What is the largest prime factor of the number 600851475143 ?</p>
</div> <!-- ezero_problem -->

<div id="ezero_solution">
All this problem really needs is a basic function to figure out the largest prime factor.  As with Problem 2, the problem essentially describes the solution.
<p>
I used a simple (and common) method of sucessive division to test candidate divisors - by
successively dividing by smaller candidate numbers, larger multiples of those numbers (which will
by definition be non-prime) will be eliminated as we increment our candidate number. It costs 
an extra division for each non-prime we've already tested a divisor of, but this is more than 
offset by skipping the cost of trying to test each candidate divisor for primality. It also has 
the advantage of simplicity. I certainly didn't think of this method first (no idea where I 
first saw it) and there are probably methods that are faster, but it doesn't matter as much here
because the point for this project is zero-runtime (all calculations are actually done before 
the program is ever run).
</p>
<p>For the zero-runtime version, the C++14 relaxations on constexpr functions are used. 
The code is exactly the same for both the calc-at-execution and zero-runtime 
implementations - the CAX version just hides constexpr.with a #define directive 
(hiding a keyword with the preprocessor is extremely bad practice, but this isn't a real program). 
The CAX version also needs the <code>-Wno-long-long</code> option for some compilers, as <code>'long long'</code>
is not officially part of ISO C++ 1998 (it's a compiler extension prior to C++11) and we treat 
all warnings as errors.
 </p>
</div> <!-- ezero_solution -->

</body>
</html>
