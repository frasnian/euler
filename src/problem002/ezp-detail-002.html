<!DOCTYPE html>
<html style="height:100%;">
<!--
<copyright>
// This is a part of Euler Zero - see https://github.com/frasnian/euler-zero
// Copyright (c) 2015-2017 David Starr
//
// Distributed under the Boost Software License, Version 1.0. 
// (See accompanying file LICENSE_1_0.txt or copy at 
// http://www.boost.org/LICENSE_1_0.txt)
//
</copyright>
-->
<head>
<meta charset="UTF-8"> 
<link rel="stylesheet" type="text/css" href="../../doc/euler-zero.css">
<script type="text/javascript" src="../../doc/common.js"></script>
<script type="text/javascript" src="../../doc/detailpage.js"></script>
<script type="text/javascript" src="../../doc/euler-zero-problems.js"></script>
<script type="text/javascript" src="../../doc/.euler-zero-prefs.js" ></script>
<script type="text/javascript" src="ezp-docvar-002.js"></script>
</head>
<body onload="standardDetailPageElements()">

<div id="ezero_problem">
    Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
    <p align="center">1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...</p>
    By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
</div> <!-- ezero_problem -->

<div id="ezero_detail">
    Problem 2 is pretty easy: just calculate the sum of all even Fibonacci numbers less than four million. Simple enough, right?
    Sure, if you can do it with an iterative solution. However, for a zero-runtime solution 
    we can't really use an equally straightforward (but less efficient) recursive templated solution that results in 
    a recursion depth of ~3.52M. After thinking about different ways to accomplish this with template metaprogramming 
    (all of which are essentially ugly workarounds to the fact that all C++ TMP looping basically boils down to recursion of some sort), I decided I would just go the easy route and use the relaxations on <code>constexpr</code> in C++14 for this one. 
    <p>I initially had <a href="http://frasnian.blogspot.com/2015/02/euler-zero-doa.html" target="_blank">mixed feelings</a> about using 
    <code>contexpr</code> functions, and it&apos;s what killed my interest in this project for a while (it turns out I was quite wrong about how challenging a zero-runtime implementation would be for some problems, even with relaxations on <code>constexpr</code> which is why this is interesting again).  That being said, I used them for this problem - and by doing so this problem is not one that presents difficulties in expressing as a zero-rumtime solution.</p>
    <p>The code for the calculation-at-execution and zero-runtime solutions is exactly the same, the only difference is in the compiler options that determine when things get either evaluated (ZRT) or compiled (CAX).
    </p>
    <p>The code is pretty self-explanatory for this one, no additional commentary should be necessary.</p>
    

    </div> <!-- ezero_detail -->

</body>
</html>
